var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EarthSciMLBase","category":"page"},{"location":"#EarthSciMLBase","page":"Home","title":"EarthSciMLBase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EarthSciMLBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains utilities for constructing Earth Science models in Julia using ModelingToolkit.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EarthSciMLBase]","category":"page"},{"location":"#EarthSciMLBase.AbstractEarthSciMLSystem","page":"Home","title":"EarthSciMLBase.AbstractEarthSciMLSystem","text":"One or more ModelingToolkit systems of equations. EarthSciML uses custom types to allow  automatic composition of different systems together.\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.Advection","page":"Home","title":"EarthSciMLBase.Advection","text":"Apply advection to a model.\n\nExample\n\nusing EarthSciMLBase\nusing DomainSets, MethodOfLines, ModelingToolkit, Plots\n\n# Create our independent variable `t` and our partially-independent variable `x`.\n@parameters t, x\n\n# Create our ODE system of equations as a subtype of `EarthSciMLODESystem`.\n# Creating our system in this way allows us to convert it to a PDE system \n# using just the `+` operator as shown below.\nstruct ExampleSys <: EarthSciMLODESystem\n    sys::ODESystem\n    function ExampleSys(t; name)\n        @variables y(t)\n        @parameters p=2.0\n        D = Differential(t)\n        new(ODESystem([D(y) ~ p], t; name))\n    end\nend\n@named sys = ExampleSys(t)\n\n# Create our initial and boundary conditions.\nicbc = ICBC(constBC(1.0, x ∈ Interval(0, 1.0)), constIC(0.0, t ∈ Interval(0, 1.0)))\n\n# Convert our ODE system to a PDE system and add advection to each of the state variables.\n# We're also adding a constant wind in the x-direction, with a speed of 1.0.\nsys_advection = sys + icbc + ConstantWind(t, 1.0) + Advection()\nsys_mtk = get_mtk(sys_advection)\n\n# Discretize the system and solve it.\ndiscretization = MOLFiniteDifference([x=>10], t, approx_order=2)\n@time prob = discretize(sys_mtk, discretization)\n@time sol = solve(prob, Tsit5(), saveat=0.1)\n\n# Plot the solution.\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\n@variables sys₊y(..)\nsoly = sol[sys₊y(x, t)]\nanim = @animate for k in 1:length(discrete_t)\n    plot(soly[1:end, k], title=\"t=$(discrete_t[k])\", ylim=(0,2.5), lab=:none)\nend\ngif(anim, fps = 8)\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.ComposedEarthSciMLSystem","page":"Home","title":"EarthSciMLBase.ComposedEarthSciMLSystem","text":"A system for composing together other systems using the + operator.\n\nThe easiest way to explain how this works and why we might want to do it is with an example. The following example is modified from the ModelingToolkit.jl documentation  here:\n\nExample:\n\nusing EarthSciMLBase\nusing ModelingToolkit\n\n# Set up our independent variable time, which will be shared by all systems.\n@parameters t\n\n# Create three systems which we will compose together.\nstruct SEqn <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function SEqn(t) \n        @variables S(t), I(t), R(t)\n        D = Differential(t)\n        N = S + I + R\n        @parameters β\n        @named seqn = ODESystem([D(S) ~ -β*S*I/N])\n        new(seqn)\n    end\nend\n\nstruct IEqn <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function IEqn(t) \n        @variables S(t), I(t), R(t)\n        D = Differential(t)\n        N = S + I + R\n        @parameters β,γ\n        @named ieqn = ODESystem([D(I) ~ β*S*I/N-γ*I])\n        new(ieqn)\n    end\nend\n\nstruct REqn <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function REqn(t) \n        @variables I(t), R(t)\n        D = Differential(t)\n        @parameters γ\n        @named reqn = ODESystem([D(R) ~ γ*I])\n        new(reqn)\n    end\nend\n\n\n# Create functions to allow us to compose the systems together using the `+` operator.\nfunction Base.:(+)(s::SEqn, i::IEqn)::ComposedEarthSciMLSystem\n    seqn = s.sys\n    ieqn = i.sys\n    ComposedEarthSciMLSystem(\n        ConnectorSystem([\n            ieqn.S ~ seqn.S,\n            seqn.I ~ ieqn.I], s, i), \n        s, i,\n    )\nend\n\nfunction Base.:(+)(s::SEqn, r::REqn)::ComposedEarthSciMLSystem\n    seqn = s.sys\n    reqn = r.sys\n    ComposedEarthSciMLSystem(\n        ConnectorSystem([seqn.R ~ reqn.R], s, r), \n        s, r,\n    )\nend\n\nfunction Base.:(+)(i::IEqn, r::REqn)::ComposedEarthSciMLSystem\n    ieqn = i.sys\n    reqn = r.sys\n    ComposedEarthSciMLSystem(\n        ConnectorSystem([\n            ieqn.R ~ reqn.R,\n            reqn.I ~ ieqn.I], i, r), \n        i, r,\n    )\nend\n\n# Instantiate our three systems.\nseqn, ieqn, reqn = SEqn(t), IEqn(t), REqn(t)\n\n# Compose the systems together using the `+` operator. This is the fancy part!\nsir = seqn + ieqn + reqn\n\n# Finalize the system for solving.\nsirfinal = get_mtk(sir)\n\n# Show the equations in our combined system.\nequations(structural_simplify(sirfinal))\n\n# output\n3-element Vector{Equation}:\n Differential(t)(reqn₊R(t)) ~ reqn₊γ*ieqn₊I(t)\n Differential(t)(seqn₊S(t)) ~ (-seqn₊β*ieqn₊I(t)*seqn₊S(t)) / (ieqn₊I(t) + reqn₊R(t) + seqn₊S(t))\n Differential(t)(ieqn₊I(t)) ~ (ieqn₊β*ieqn₊I(t)*seqn₊S(t)) / (ieqn₊I(t) + reqn₊R(t) + seqn₊S(t)) - ieqn₊γ*ieqn₊I(t)\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.ConnectorSystem","page":"Home","title":"EarthSciMLBase.ConnectorSystem","text":"A connector for two systems.\n\neqs\nfrom\nto\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.ConstantWind","page":"Home","title":"EarthSciMLBase.ConstantWind","text":"Construct a constant wind velocity model component.\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.EarthSciMLODESystem","page":"Home","title":"EarthSciMLBase.EarthSciMLODESystem","text":"A type for actual implementations of ODE systems.\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.ICBC","page":"Home","title":"EarthSciMLBase.ICBC","text":"ICBC(icbc::ICBCcomponent...)\n\nInitial and boundary conditions for a ModelingToolkit.jl PDESystem.  It can be used with the + operator to add initial and boundary conditions to a ModelingToolkit.jl ODESystem or Catalyst.jl ReactionSystem.\n\nicbc: The sets of initial and/or boundary conditions.\n\nExample:\n\nusing EarthSciMLBase\nusing ModelingToolkit, DomainSets\n\n# Set up ODE system\n@parameters x y t\n@variables u(t) v(t)\nDt = Differential(t)\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = 1.0\nt_max = 11.5\n\neqs = [\n    Dt(u) ~ √abs(v),\n    Dt(v) ~ √abs(u),\n]\n\n@named sys = ODESystem(eqs)\n\n# Create constant initial conditions = 16.0 and boundary conditions = 4.0.\nicbc = ICBC(\n    constBC(16.0, \n        x ∈ Interval(x_min, x_max),\n        y ∈ Interval(y_min, y_max),\n    ),\n    constIC(4.0, t ∈ Interval(t_min, t_max)),\n)\n\n# Convert to PDESystem and add constant initial and boundary conditions.\npdesys = sys + icbc\n\npdesys.bcs\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.ICBCcomponent","page":"Home","title":"EarthSciMLBase.ICBCcomponent","text":"Initial and boundary condition components that can be combined to  create an ICBC object.\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.MeanWind","page":"Home","title":"EarthSciMLBase.MeanWind","text":"A model component that represents the mean wind velocity, where t is the independent variable and ndims is the number of dimensions that wind is traveling in.\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.constBC","page":"Home","title":"EarthSciMLBase.constBC","text":"Construct constant boundary conditions equal to the value  specified by val.\n\nval: The value of the constant boundary conditions.\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.constIC","page":"Home","title":"EarthSciMLBase.constIC","text":"Construct constant initial conditions equal to the value  specified by val.\n\nval: The value of the constant initial conditions.\nindepdomain: The independent domain, e.g. t ∈ Interval(t_min, t_max).\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.periodicBC","page":"Home","title":"EarthSciMLBase.periodicBC","text":"Construct periodic boundary conditions for the given partialdomains. Periodic boundary conditions are defined as when the value at one side of the domain is set equal to the value at the other side, so  that the domain \"wraps around\" from one side to the other.\n\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.zerogradBC","page":"Home","title":"EarthSciMLBase.zerogradBC","text":"Construct zero-gradient boundary conditions for the given partialdomains.\n\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"#EarthSciMLBase.add_dims-Tuple{Any, AbstractVector, AbstractVector}","page":"Home","title":"EarthSciMLBase.add_dims","text":"add_dims(expression, vars, dims)\nadd_dims(equation, vars, dims)\n\nAdd the given dimensions to each variable in vars in the given expression or equation.  Each variable in vars must be unidimensional, i.e. defined like @variables u(t) rather than @variables u(..).\n\nExample:\n\nusing EarthSciMLBase, ModelingToolkit\n\n@parameters x y k t\n@variables u(t) q(t)\nexp = 2u + 3k*q + 1\nEarthSciMLBase.add_dims(exp, [u, q], [x, y, t])\n\n# output\n1 + 2u(x, y, t) + 3k*q(x, y, t)\n\n\n\n\n\n","category":"method"},{"location":"#EarthSciMLBase.dims-Tuple{EarthSciMLBase.ICcomponent}","page":"Home","title":"EarthSciMLBase.dims","text":"dims(\n    icbc::EarthSciMLBase.ICcomponent\n) -> Vector{Symbolics.Num}\n\n\nReturns the dimensions of the independent and partial domains associated with these  initial or boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"#EarthSciMLBase.domains-Tuple{EarthSciMLBase.ICcomponent}","page":"Home","title":"EarthSciMLBase.domains","text":"domains(icbc::EarthSciMLBase.ICcomponent) -> Vector\n\n\nReturns the domains associated with these initial or boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"#EarthSciMLBase.get_mtk-Tuple{AbstractEarthSciMLSystem}","page":"Home","title":"EarthSciMLBase.get_mtk","text":"\n\njulia get_mtk(     sys::AbstractEarthSciMLSystem ) -> ModelingToolkit.AbstractSystem\n\n\n\n\nReturn the ModelingToolkit version of this system.\n\n\n\n\n\n","category":"method"},{"location":"#EarthSciMLBase.ivar-Tuple{ICBC}","page":"Home","title":"EarthSciMLBase.ivar","text":"ivar(icbc::ICBC) -> Any\n\n\nReturn the independent variable associated with these  initial and boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"#EarthSciMLBase.operator_compose-Tuple{EarthSciMLODESystem, EarthSciMLODESystem}","page":"Home","title":"EarthSciMLBase.operator_compose","text":"operator_compose(\n    a::EarthSciMLODESystem,\n    b::EarthSciMLODESystem\n) -> ComposedEarthSciMLSystem\n\n\nCompose to systems of equations together by adding the right-hand side terms together of equations that have matching left-hand sides.\n\nThe example below shows that when we operator_compose two systems together that are both equal to D(x) = p, the resulting system is equal to D(x) = 2p.\n\nExample\n\nusing EarthSciMLBase\nusing ModelingToolkit\n\n@parameters t\n\nstruct ExampleSys <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function ExampleSys(t; name)\n        @variables x(t)\n        @parameters p\n        D = Differential(t)\n        new(ODESystem([D(x) ~ p], t; name))\n    end\nend\n\n@named sys1 = ExampleSys(t)\n@named sys2 = ExampleSys(t)\n\ncombined = operator_compose(sys1, sys2)\n\ncombined_mtk = get_mtk(combined)\nequations(structural_simplify(combined_mtk))\n\n# The simplified equation should be D(x) = p + sys2_xˍt, where sys2_xˍt is also equal to p.\n# output\n1-element Vector{Equation}:\n Differential(t)(sys1₊x(t)) ~ sys1₊p + sys2₊sys2_xˍt(t)\n\n\n\n\n\n","category":"method"},{"location":"#EarthSciMLBase.pvars-Tuple{ICBC}","page":"Home","title":"EarthSciMLBase.pvars","text":"pvars(icbc::ICBC) -> Any\n\n\nReturn the partial independent variables associated with these  initial and boundary conditions.\n\n\n\n\n\n","category":"method"}]
}
