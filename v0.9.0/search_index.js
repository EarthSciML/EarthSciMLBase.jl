var documenterSearchIndex = {"docs":
[{"location":"api/#API-Index","page":"API Reference","title":"API Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#API-Documentation","page":"API Reference","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [EarthSciMLBase]","category":"page"},{"location":"api/#EarthSciMLBase.AbstractEarthSciMLSystem","page":"API Reference","title":"EarthSciMLBase.AbstractEarthSciMLSystem","text":"One or more ModelingToolkit systems of equations. EarthSciML uses custom types to allow  automatic composition of different systems together.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.Advection","page":"API Reference","title":"EarthSciMLBase.Advection","text":"Apply advection to a model.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ComposedEarthSciMLSystem","page":"API Reference","title":"EarthSciMLBase.ComposedEarthSciMLSystem","text":"A system for composing together other systems using the + operator.\n\nsystems: Model components to be composed together\ndomaininfo: Initial and boundary conditions and other domain information\npdefunctions: A vector of functions where each function takes as an argument the resulting PDESystem after DomainInfo is added to this system, and returns a transformed PDESystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ConnectorSystem","page":"API Reference","title":"EarthSciMLBase.ConnectorSystem","text":"A connector for two systems.\n\neqs\nfrom\nto\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ConstantWind","page":"API Reference","title":"EarthSciMLBase.ConstantWind","text":"Construct a constant wind velocity model component with the given wind speed(s), which should include units. For example, ConstantWind(t, 1u\"m/s\", 2u\"m/s\").\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.DomainInfo","page":"API Reference","title":"EarthSciMLBase.DomainInfo","text":"Domain information for a ModelingToolkit.jl PDESystem.  It can be used with the + operator to add initial and boundary conditions  and coordinate transforms to a ModelingToolkit.jl ODESystem or Catalyst.jl ReactionSystem.\n\nNOTE: The independent variable (usually time) must be first in the list of initial and boundary conditions.\n\npartial_derivative_func: Function that returns spatial derivatives of the partially-independent variables, optionally performing a coordinate transformation first.\nCurrent function options are:\npartialderivatives_identity (the default): Returns partial derivatives without performing any coordinate transforms.\npartialderivatives_lonlat2xymeters: Returns partial derivatives after transforming any variables named lat and lon\nfrom degrees to cartesian meters, assuming a spherical Earth.\n\nicbc: The sets of initial and/or boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.EarthSciMLODESystem","page":"API Reference","title":"EarthSciMLBase.EarthSciMLODESystem","text":"A type for actual implementations of ODE systems.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ICBCcomponent","page":"API Reference","title":"EarthSciMLBase.ICBCcomponent","text":"Initial and boundary condition components that can be combined to  create an DomainInfo object.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.MeanWind","page":"API Reference","title":"EarthSciMLBase.MeanWind","text":"A model component that represents the mean wind velocity, where t is the independent variable, iv is the independent variable, and pvars is the partial dependent variables for the domain.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.constBC","page":"API Reference","title":"EarthSciMLBase.constBC","text":"Construct constant boundary conditions equal to the value  specified by val.\n\nval: The value of the constant boundary conditions.\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.constIC","page":"API Reference","title":"EarthSciMLBase.constIC","text":"Construct constant initial conditions equal to the value  specified by val.\n\nval: The value of the constant initial conditions.\nindepdomain: The independent domain, e.g. t ∈ Interval(t_min, t_max).\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.periodicBC","page":"API Reference","title":"EarthSciMLBase.periodicBC","text":"Construct periodic boundary conditions for the given partialdomains. Periodic boundary conditions are defined as when the value at one side of the domain is set equal to the value at the other side, so  that the domain \"wraps around\" from one side to the other.\n\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.zerogradBC","page":"API Reference","title":"EarthSciMLBase.zerogradBC","text":"Construct zero-gradient boundary conditions for the given partialdomains.\n\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.add_dims-Tuple{Any, AbstractVector, AbstractVector}","page":"API Reference","title":"EarthSciMLBase.add_dims","text":"add_dims(expression, vars, dims)\nadd_dims(equation, vars, dims)\n\nAdd the given dimensions to each variable in vars in the given expression or equation.  Each variable in vars must be unidimensional, i.e. defined like @variables u(t) rather than @variables u(..).\n\nExample:\n\nusing EarthSciMLBase, ModelingToolkit\n\n@parameters x y k t\n@variables u(t) q(t)\nexp = 2u + 3k*q + 1\nEarthSciMLBase.add_dims(exp, [u, q], [x, y, t])\n\n# output\n1 + 2u(x, y, t) + 3k*q(x, y, t)\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.add_metadata-Tuple{Any, Any}","page":"API Reference","title":"EarthSciMLBase.add_metadata","text":"Add the units and description in the variable from to the variable to.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.add_scope-Tuple{Any, Any, Any}","page":"API Reference","title":"EarthSciMLBase.add_scope","text":"add_scope(sys, v, iv)\n\n\nAdd a system scope to a variable name, for example so that  x in system sys1 becomes sys1₊x. iv is the independent variable.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.couple-Tuple{}","page":"API Reference","title":"EarthSciMLBase.couple","text":"Couple two systems together. This function should be overloaded for each pair of  systems that can be coupled together.\n\nIn the get_mtk method of ComposedEarthSciMLSystem, this function is called to make any edits needed to the two systems before they are composed together, and also to return a ConnectorSystem that represents the coupling of the two systems.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.dims-Tuple{EarthSciMLBase.ICcomponent}","page":"API Reference","title":"EarthSciMLBase.dims","text":"dims(\n    icbc::EarthSciMLBase.ICcomponent\n) -> Vector{Symbolics.Num}\n\n\nReturns the dimensions of the independent and partial domains associated with these  initial or boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.domains-Tuple{EarthSciMLBase.ICcomponent}","page":"API Reference","title":"EarthSciMLBase.domains","text":"domains(icbc::EarthSciMLBase.ICcomponent) -> Vector\n\n\nReturns the domains associated with these initial or boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.get_dv-Tuple{Any, Any}","page":"API Reference","title":"EarthSciMLBase.get_dv","text":"Return the dependent variable, which is the first argument of the term,  unless the term is a time derivative, in which case the dependent variable  is the argument of the time derivative.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.get_mtk-Tuple{AbstractEarthSciMLSystem}","page":"API Reference","title":"EarthSciMLBase.get_mtk","text":"\n\njulia get_mtk(     sys::AbstractEarthSciMLSystem ) -> ModelingToolkit.AbstractSystem\n\n\n\n\nReturn the ModelingToolkit version of this system.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.graph-Tuple{ComposedEarthSciMLSystem}","page":"API Reference","title":"EarthSciMLBase.graph","text":"Create a graph from a ComposedEarthSciMLSystem using the MetaGraphsNext package.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.icbc-Tuple{DomainInfo, AbstractVector}","page":"API Reference","title":"EarthSciMLBase.icbc","text":"icbc(di, states)\n\n\nReturn a vector of equations that define the initial and boundary conditions for the  given state variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.ivar-Tuple{DomainInfo}","page":"API Reference","title":"EarthSciMLBase.ivar","text":"ivar(di::DomainInfo) -> Any\n\n\nReturn the independent variable associated with these  initial and boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.operator_compose","page":"API Reference","title":"EarthSciMLBase.operator_compose","text":"operator_compose(a, b)\noperator_compose(a, b, translate)\n\n\nCompose to systems of equations together by adding the right-hand side terms together of equations that have matching left-hand sides. The left hand sides of two equations will be considered matching if:\n\nThey are both time derivatives of the same variable.\nThe first one is a time derivative of a variable and the second one is the variable itself.\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, e.g. Dict(sys1.sys.x => sys2.sys.y).\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, with a conversion factor, e.g. Dict(sys1.sys.x => sys2.sys.y => 6).\n\n\n\n\n\n","category":"function"},{"location":"api/#EarthSciMLBase.param_to_var-Tuple{ModelingToolkit.AbstractSystem, Vararg{Symbol}}","page":"API Reference","title":"EarthSciMLBase.param_to_var","text":"Replace the parameter p in the system sys with a new variable that has  the same name, units, and description as p.\n\nparam_to_var(sys, ps)\n\n\nThis can be useful to replace a parameter that does not change in time in a model component  with one specified by another system that does change in time (or space). For example, the  code below specifies a first-order loss equation, and then changes the temperature (which  determines the loss rate) with a temperature value that varies in time. ```\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.partialderivatives_identity-Tuple{AbstractVector}","page":"API Reference","title":"EarthSciMLBase.partialderivatives_identity","text":"partialderivatives_identity(pvars)\n\n\nReturn the partial derivative operators corresponding to each of the given partial-independent variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.partialderivatives_lonlat2xymeters-Tuple{AbstractVector}","page":"API Reference","title":"EarthSciMLBase.partialderivatives_lonlat2xymeters","text":"partialderivatives_lonlat2xymeters(pvars; default_lat)\n\n\nReturn the partial derivative operators corresponding to each of the given partial-independent variables after converting variables named lon and lat from degrees to x and y meters,  assuming they represent longitude and latitude on a spherical Earth.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.pvars-Tuple{DomainInfo}","page":"API Reference","title":"EarthSciMLBase.pvars","text":"pvars(di::DomainInfo) -> Any\n\n\nReturn the partial independent variables associated with these  initial and boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"icbc/#Initial-and-Boundary-conditions","page":"Initial and Boundary Conditions","title":"Initial and Boundary conditions","text":"","category":"section"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Oftentimes we will want to do a 1, 2, or 3-dimensional simulation, rather than the 0-dimensional simulation we get by default with a system of ordinary differential equations. In these cases, we will need to specify initial and boundary conditions for the system.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"To demonstrate how to do this, we will use the following simple system of ordinary differential equations:","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"using EarthSciMLBase\nusing ModelingToolkit\n\nstruct ExampleSys <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function ExampleSys(t; name=:example)\n        @variables u(t) v(t)\n        Dt = Differential(t)\n        eqs = [\n            Dt(u) ~ √abs(v),\n            Dt(v) ~ √abs(u),\n        ]\n        new(ODESystem(eqs, t; name))\n    end\nend\nnothing # hide","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Next, we specify our initial and boundary conditions using the DomainInfo type. We initialize DomainInfo with sets of initial and boundary conditions. In the example below, we set constant initial conditions using constIC and constant boundary conditions using constBC.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"using DomainSets\n\n@parameters x y t\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = t_max = 1.0\n\n# Create constant initial conditions = 16.0 and boundary conditions = 4.0.\nicbc = DomainInfo(\n    constIC(4.0, t ∈ Interval(t_min, t_max)),\n    constBC(16.0,\n        x ∈ Interval(x_min, x_max),\n        y ∈ Interval(y_min, y_max),\n    ),\n)\nnothing # hide","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"It is also possible to use periodic boundary conditions with periodicBC and zero-gradient boundary conditions with zerogradBC.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Finally, we combine our initial and boundary conditions with our system of equations using the + operator.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"model = ExampleSys(t) + icbc\n\neq_sys = get_mtk(model)","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"We can also look at the expanded boundary conditions of the resulting equation system:","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"eq_sys.bcs","category":"page"},{"location":"operator_compose/#Operator-Composition","page":"Operator Composition","title":"Operator Composition","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"There are a lot of cases where there are two different \"processes\" or \"operators\" that change the same variable.  For example, CO2 in the atmosphere can be emitted by human activity, and it can also be absorbed by the ocean. In models, typically the emission and removal are considered separate processes which are represented by separate model components. However, when we want to combine these two components into a single model, we need to be able to compose them together.","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"We can use the operator_compose function for this. It composes to systems of equations together by adding the right-hand side terms together of equations that have matching left-hand sides. The left hand sides of two equations will be considered matching if:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"They are both time derivatives of the same variable.\nThe first one is a time derivative of a variable and the second one is the variable itself.\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, e.g. Dict(sys1.sys.x => sys2.sys.y).\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, with a conversion factor, e.g. Dict(sys1.sys.x => sys2.sys.y => 6).","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"Perhaps we can make this somewhat clearer with some examples.","category":"page"},{"location":"operator_compose/#Examples","page":"Operator Composition","title":"Examples","text":"","category":"section"},{"location":"operator_compose/#Example-with-matching-variable-time-derivatives","page":"Operator Composition","title":"Example with matching variable time derivatives","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"The example below shows that when we operator_compose two systems together that are both equal to D(x) = p, the resulting system is equal to D(x) = 2p.","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"using EarthSciMLBase\nusing ModelingToolkit\n\n@parameters t\n\nstruct ExampleSys <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function ExampleSys(t; name)\n        @variables x(t)\n        @parameters p\n        D = Differential(t)\n        new(ODESystem([D(x) ~ p], t; name))\n    end\nend\n\nstruct ExampleSys2 <: EarthSciMLODESystem\n    sys::ODESystem\n\n    function ExampleSys2(t; name)\n        @variables x(t)\n        @parameters p\n        D = Differential(t)\n        new(ODESystem([D(x) ~ 2p], t; name))\n    end\nend\n\n@named sys1 = ExampleSys(t)\n@named sys2 = ExampleSys2(t)\n\nEarthSciMLBase.couple(sys1::ExampleSys, sys2::ExampleSys2) = operator_compose(sys1, sys2)\n\ncombined = sys1 + sys2\n\ncombined_mtk = get_mtk(combined)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"The simplified equation should be D(x) = p + sys2_xˍt:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"combined_simplified = structural_simplify(combined_mtk)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"where sys2_xˍt is also equal to p:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(combined_simplified)","category":"page"},{"location":"operator_compose/#Example-with-non-matching-variables","page":"Operator Composition","title":"Example with non-matching variables","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"This example demonstrates a case where one variable in the first system is equal to another variable in the second system:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"struct ExampleSys3 <: EarthSciMLODESystem\n    sys::ODESystem\n    function ExampleSys3(t; name)\n        @variables y(t)\n        @parameters p\n        D = Differential(t)\n        new(ODESystem([D(y) ~ p], t; name))\n    end\nend\n\n@named sys1 = ExampleSys(t)\n@named sys2 = ExampleSys3(t)\n\nfunction EarthSciMLBase.couple(sys1::ExampleSys, sys2::ExampleSys3)\n    operator_compose(sys1, sys2, Dict(sys1.sys.x => sys2.sys.y))\nend\n\ncombined = sys1 + sys2\ncombined_simplified = structural_simplify(get_mtk(combined))","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(combined_simplified)","category":"page"},{"location":"operator_compose/#Example-with-a-non-ODE-system","page":"Operator Composition","title":"Example with a non-ODE system","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"In the second case above, we might have a variable in the second system that is equal to a rate, but it is not a time derivative. This could happen if we are extracting emissions from a file, and those emissions are already in units of kg/s, or something similar. The example below demonstrates this case.  (Note that this case can also be used with the conversion factors shown in the last example.)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"struct ExampleSysNonODE <: EarthSciMLODESystem\n    sys::ODESystem\n    function ExampleSysNonODE(t; name)\n        @variables y(t)\n        @parameters p\n        new(ODESystem([y ~ p], t; name))\n    end\nend\n\n@named sys1 = ExampleSys(t)\n@named sys2 = ExampleSysNonODE(t)\n\nfunction EarthSciMLBase.couple(sys1::ExampleSys, sys2::ExampleSysNonODE)\n    operator_compose(sys1, sys2, Dict(sys1.sys.x => sys2.sys.y))\nend\n\ncombined = sys1 + sys2\nsys_combined = structural_simplify(get_mtk(combined))","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(sys_combined)","category":"page"},{"location":"operator_compose/#Example-with-non-matching-variables-and-a-conversion-factor","page":"Operator Composition","title":"Example with non-matching variables and a conversion factor","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"Finally, this last example shows the fourth case, where a conversion factor is included in the translation dictionary.","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"@named sys1 = ExampleSys(t)\n@named sys2 = ExampleSysNonODE(t)\n\nfunction EarthSciMLBase.couple(sys1::ExampleSys, sys2::ExampleSysNonODE)\n    operator_compose(sys1, sys2, Dict(sys1.sys.x => sys2.sys.y => 6.0))\nend\n\ncombined = sys1 + sys2\ncombined_simplified = structural_simplify(get_mtk(combined))","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(combined_simplified)","category":"page"},{"location":"param_to_var/#Converting-parameters-to-variables","page":"Parameter Replacement","title":"Converting parameters to variables","text":"","category":"section"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"This can be useful to replace a parameter that does not change in time in a model component  with one specified by another system that does change in time (or space). For example, the  code below specifies a first-order loss equation, and then changes the temperature (which  determines the loss rate) with a temperature value that varies in time.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"As an example, we will create a loss equation that depends on the temperature, starting with a constant temperature. We will then create a temperature equation that varies in time, and use the param_to_var function to replace the constant temperature in the loss equation with the time-varying temperature.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"So first, let's specify the original system with constant temperature.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"using ModelingToolkit, EarthSciMLBase, Unitful\n\nstruct Loss <: EarthSciMLODESystem\n    sys::ODESystem\n    Loss(sys::ModelingToolkit.ODESystem) = new(sys)\n    function Loss(t)\n        @variables A(t)=1 [unit=u\"kg\"]\n        @parameters k=1 [unit=u\"s^-1\"]\n        @parameters T=300 [unit=u\"K\"]\n        @constants T₀=300 [unit=u\"K\"]\n        eq = Differential(t)(A) ~ -k*exp(T/T₀) * A\n        new(ODESystem([eq]; name=:loss))\n    end\nend","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"Next, we specify the temperature that varies in time.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"struct Temperature <: EarthSciMLODESystem\n    sys::ODESystem\n    function Temperature(t)\n        @variables T(t)=300 [unit=u\"K\"]\n        @constants Tc=1.0 [unit=u\"K/s\"]\n        @constants tc=1.0 [unit=u\"s\"]\n        eq = Differential(t)(T) ~ sin(t/tc)*Tc\n        new(ODESystem([eq]; name=:temperature))\n    end\nend","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"Now, we specify how to compose the two systems using param_to_var.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"function EarthSciMLBase.couple(loss::Loss, temp::Temperature)\n    loss = Loss(param_to_var(loss.sys, :T))\n    losseqn = loss.sys\n    teqn = temp.sys\n    ConnectorSystem([losseqn.T ~ teqn.T], loss, temp)\nend","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"Finally, we create the system components and the composed system.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"@variables t [unit=u\"s\", description=\"time\"]\nl = Loss(t)\nt = Temperature(t)\nvariable_loss = l+t\n\nget_mtk(variable_loss)","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"If we wanted to, we could then run a simulation with the composed system.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"CurrentModule = EarthSciMLBase","category":"page"},{"location":"example_all_together/#Example-using-different-components-of-EarthSciMLBase-together","page":"All Together","title":"Example using different components of EarthSciMLBase together","text":"","category":"section"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"This example shows how to define and couple different components of EarthSciMLBase together to create a more complex model. First, we create several model components.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Our first example system is a simple reaction system:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"using EarthSciMLBase\nusing ModelingToolkit, Catalyst, DomainSets, MethodOfLines, DifferentialEquations\nusing Plots\n\n# Create our independent variable `t` and our partially-independent variables `x` and `y`.\n@parameters t x y\n\nstruct ExampleSys1 <: EarthSciMLODESystem\n    sys\n    function ExampleSys1(t; name=:sys1)\n        @species c₁(t)=5.0 c₂(t)=5.0\n        new(convert(ODESystem, ReactionSystem(\n            [Reaction(2.0, [c₁], [c₂])],\n            t; name=name,\n        ), combinatoric_ratelaws=false))\n    end\nend\nnothing # hide","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Our second example system is a simple ODE system, with the same two variables.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"struct ExampleSys2 <: EarthSciMLODESystem\n    sys\n    function ExampleSys2(t; name=:sys2)\n        @variables c₁(t)=5.0 c₂(t)=5.0\n        @parameters p₁=1.0 p₂=0.5\n        D = Differential(t)\n        new(ODESystem(\n            [D(c₁) ~ -p₁, D(c₂) ~ p₂],\n            t; name=name,\n        ))\n    end\nend\nnothing # hide","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Now, we specify what should happen when we couple the two systems together. In this case, we want the the derivative of the composed system to  be equal to the sum of the derivatives of the two systems. We can do that using the operator_compose function  from this package.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"EarthSciMLBase.couple(sys1::ExampleSys1, sys2::ExampleSys2) = operator_compose(sys1, sys2)\nnothing # hide","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Once we specify all of the above, it is simple to create our two individual systems and then couple them together. ","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"@named sys1 = ExampleSys1(t)\n@named sys2 = ExampleSys2(t)\nsys = sys1 + sys2","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"At this point we have an ODE system that is composed of two other ODE systems. We can inspect its observed variables using the observed function.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"simplified_sys = structural_simplify(get_mtk(sys))","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"observed(simplified_sys)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"We can also run simulations using this system:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"odeprob = ODEProblem(simplified_sys, [], (0.0,10.0), [])\nodesol = solve(odeprob)\nplot(odesol)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Once we've confirmed that our model works in a 0D \"box model\" setting, we can expand it to 1, 2, or 3 dimensions using by adding in initial  and boundary conditions. We will also add in advection using constant-velocity wind fields add the same time.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"x_min = y_min = t_min = 0.0\nx_max = y_max = t_max = 1.0\ndomain = DomainInfo(\n    constIC(4.0, t ∈ Interval(t_min, t_max)),\n    periodicBC(x ∈ Interval(x_min, x_max)),\n    zerogradBC(y ∈ Interval(y_min, y_max)),\n)\n\nsys_pde = ExampleSys1(t) + ExampleSys2(t) + domain + ConstantWind(t, 1.0, 1.0) + Advection()\n\nsys_pde_mtk = get_mtk(sys_pde)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Now we can inspect this new system that we've created:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"sys_pde_mtk.dvs","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"sys_pde_mtk.bcs","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Finally, we can run a simulation using this system:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"discretization = MOLFiniteDifference([x=>10, y=>10], t, approx_order=2)\n@time pdeprob = discretize(sys_pde_mtk, discretization)\n@time pdesol = solve(pdeprob, Tsit5(), saveat=0.1)\n\n# Plot the solution.\ndiscrete_x, discrete_y, discrete_t = pdesol[x], pdesol[y], pdesol[t]\n@variables sys1₊c₁(..) sys1₊c₂(..)\nsolc1, solc2 = pdesol[sys1₊c₁(t, x, y)], pdesol[sys1₊c₂(t, x, y)]\nanim = @animate for k in 1:length(discrete_t)\n    p1 = heatmap(solc1[k, 1:end-1, 1:end-1], title=\"c₁ t=\\$(discrete_t[k])\", clim=(0,4.0), lab=:none)\n    p2 = heatmap(solc2[k, 1:end-1, 1:end-1], title=\"c₂ t=\\$(discrete_t[k])\", clim=(0,7.0), lab=:none)\n    plot(p1, p2, layout=(1,2), size=(800,400))\nend\ngif(anim, fps = 8)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Because our system is a system of ordinary differential equations rather than partial differential equations, all of the grid cells in the animation above have the same value. Refer to the advection example for an example of a system of partial differential equations.","category":"page"},{"location":"composition/#Model-Composition","page":"Composition","title":"Model Composition","text":"","category":"section"},{"location":"composition/","page":"Composition","title":"Composition","text":"A main goal of the EarthSciMLBase package is to allow model components to be created independently and composed together.  We achieve this by creating type, EarthSciMLODESystem, which is a wrapper around the ODESystem type from the ModelingToolkit package.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"For example, below we define three model components, Photolysis, Chemistry, and Emissions, which represent different processes in the atmosphere. Each of these components is defined as a subtype of EarthSciMLODESystem and contains an ODESystem object named sys. Each of them also included a constructor function which takes a time variable t as an argument and returns an instance of the model component, including an initialized version of the ModelingToolkit model component.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"using ModelingToolkit, Catalyst, EarthSciMLBase\n\nstruct Photolysis <: EarthSciMLODESystem\n    sys::ODESystem\n    function Photolysis(t)\n        @parameters j_unit = 1\n        @variables j_NO2(t) = 0.0149\n        eqs = [\n            j_NO2 ~ j_unit\n        ]\n        new(ODESystem(eqs, t, [j_NO2], [j_unit]; name=:photolysis))\n    end\nend\n\nstruct Chemistry <: EarthSciMLODESystem\n    sys::ODESystem\n    Chemistry(sys::ODESystem) = new(sys)\n    function Chemistry(t)\n        @parameters jNO2 = 0.0149\n        @species NO2(t) = 10.0\n        rxs = [\n            Reaction(jNO2, [NO2], [], [1], [1])\n        ]\n        rxn_sys = ReactionSystem(rxs, t, [NO2], [jNO2]; \n            combinatoric_ratelaws=false, name=:chemistry)\n        new(convert(ODESystem, rxn_sys))\n    end\nend\n\nstruct Emissions <: EarthSciMLODESystem\n    sys::ODESystem\n    function Emissions(t)\n        @parameters emis = 1\n        @variables NO2(t) = 0.00014\n        eqs = [NO2 ~ emis]\n        new(ODESystem(eqs, t, [NO2], [emis]; name=:emissions))\n    end\nend\nnothing # hide","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Now, we need to define ways to couple the model components together. We can do this by defining a method of the EarthSciMLBase.couple function for each pair of model components that we want to couple. The code below define a method for coupling the Chemistry and Photolysis components.  First, it uses the param_to_var function to convert the photolysis rate parameter jNO2 from the Chemistry component to a variable, then it creates a new Chemistry component with the updated photolysis rate, and finally, it creates a ConnectorSystem object that sets the j_NO2 variable from the Photolysis component equal to the jNO2 variable from the Chemistry component. The next effect is that the photolysis rate in the Chemistry component is now controlled by the Photolysis component.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"function EarthSciMLBase.couple(c::Chemistry, p::Photolysis)\n    sys = param_to_var(c.sys, :jNO2)\n    c = Chemistry(sys)\n    ConnectorSystem([c.sys.jNO2 ~ p.sys.j_NO2], c, p)\nend\nnothing # hide","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Next, we define a method for coupling the Chemistry and Emissions components. To do this we use the operator_compose function to add the NO2 species from the Emissions component to the time derivative of NO2 in the Chemistry component.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"EarthSciMLBase.couple(c::Chemistry, emis::Emissions) = operator_compose(c, emis, Dict(\n    c.sys.NO2 => emis.sys.NO2,\n))\nnothing # hide","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Finally, we can compose the model components together to create our complete model. To do so, we just initialize each model component and add the components together using the + operator.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"@parameters t\n\nmodel  = Photolysis(t) + Chemistry(t) + Emissions(t)","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Finally, we can use the graph function to visualize the model components and their connections.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"using MetaGraphsNext\nusing CairoMakie, GraphMakie\n\ng = graph(model)\n\nf, ax, p = graphplot(g; ilabels=labels(g))\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\n\nf","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EarthSciMLBase","category":"page"},{"location":"#EarthSciMLBase:-Utilities-for-Symbolic-Earth-Science-Modeling-and-Machine-Learning","page":"Home","title":"EarthSciMLBase: Utilities for Symbolic Earth Science Modeling and Machine Learning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EarthSciMLBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains utilities for constructing Earth Science models in Julia using ModelingToolkit.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"EarthSciMLBase\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains types and functions designed to simplify the process of constructing and composing symbolically-defined Earth Science model components together.","category":"page"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Abstract types (based on AbstractEarthSciMLSystem) for wrapping ModelingToolkit.jl equation systems\nOperations to compose AbstractEarthSciMLSystems together using the + operator.\nOperations to add intitial and boundary conditions to systems and to turn ODE systems into PDE systems.\nOperations to add Advection terms to systems.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing.","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"},{"location":"advection/#Advection","page":"Advection","title":"Advection","text":"","category":"section"},{"location":"advection/","page":"Advection","title":"Advection","text":"The Advection function adds advection to a system of equations. This is useful for modeling the transport of a substance by a fluid. Advection is implemented with the Advection type.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"!warning     Fully symbolic partial differential equations like those shown here don't currently work on domains that have a large number of grid cells. See here for additional information.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"To demonstrate how this can work, we will start with a simple system of equations:","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"using EarthSciMLBase, ModelingToolkit\n\nstruct ExampleSys <: EarthSciMLODESystem\n    sys::ODESystem\n    function ExampleSys(t; name=:example)\n        @variables y(t)\n        @parameters p=2.0\n        D = Differential(t)\n        new(ODESystem([D(y) ~ p], t; name))\n    end\nend\nnothing # hide","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"We also need to create our initial and boundary conditions.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"using DomainSets\n@parameters t, x\ndomain = DomainInfo(constIC(0.0, t ∈ Interval(0, 1.0)), constBC(1.0, x ∈ Interval(0, 1.0)))\nnothing # hide","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"Now we convert add advection to each of the state variables. We're also adding a constant wind (ConstantWind) in the x-direction, with a speed of 1.0.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"sys_advection = ExampleSys(t) + domain + ConstantWind(t, 1.0) + Advection()\nsys_mtk = get_mtk(sys_advection)","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"Finally, we can discretize the system and solve it:","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"using MethodOfLines, DifferentialEquations, Plots\ndiscretization = MOLFiniteDifference([x=>10], t, approx_order=2)\n@time prob = discretize(sys_mtk, discretization)\n@time sol = solve(prob, Tsit5(), saveat=0.1)\n\n\n# Plot the solution.\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\nsoly = sol[sys_mtk.dvs[3]]\nanim = @animate for k in 1:length(discrete_t)\n    plot(discrete_x, soly[k, 1:end], title=\"t=\\$(discrete_t[k])\", ylim=(0,2.5), lab=:none)\nend\ngif(anim, fps = 8)","category":"page"}]
}
