var documenterSearchIndex = {"docs":
[{"location":"api/#API-Index","page":"API Reference","title":"API Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#API-Documentation","page":"API Reference","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [EarthSciMLBase]","category":"page"},{"location":"api/#EarthSciMLBase.coupling_registry","page":"API Reference","title":"EarthSciMLBase.coupling_registry","text":"A registery for functions to couple systems together, defined by their system hashes.\n\n\n\n\n\n","category":"constant"},{"location":"api/#EarthSciMLBase.Advection","page":"API Reference","title":"EarthSciMLBase.Advection","text":"Apply advection to a model.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ConnectorSystem","page":"API Reference","title":"EarthSciMLBase.ConnectorSystem","text":"A connector for two systems.\n\neqs\nfrom\nto\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.CoupledSystem","page":"API Reference","title":"EarthSciMLBase.CoupledSystem","text":"A system for composing together other systems using the couple function.\n\nsystems: Model components to be composed together\ndomaininfo: Initial and boundary conditions and other domain information\npdefunctions: A vector of functions where each function takes as an argument the resulting PDESystem after DomainInfo is added to this system, and returns a transformed PDESystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.DomainInfo","page":"API Reference","title":"EarthSciMLBase.DomainInfo","text":"Domain information for a ModelingToolkit.jl PDESystem.  It can be used with the + operator to add initial and boundary conditions  and coordinate transforms to a ModelingToolkit.jl ODESystem or Catalyst.jl ReactionSystem.\n\nNOTE: The independent variable (usually time) must be first in the list of initial and boundary conditions.\n\npartial_derivative_funcs: Function that returns spatial derivatives of the partially-independent variables, optionally performing a coordinate transformation first.\nCurrent function options in this package are:\npartialderivatives_δxyδlonlat: Returns partial derivatives after transforming any variables named lat and lon\nfrom degrees to cartesian meters, assuming a spherical Earth.\nOther packages may implement additional functions. They are encouraged to use function names starting with partialderivatives_.\n\nicbc: The sets of initial and/or boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ICBCcomponent","page":"API Reference","title":"EarthSciMLBase.ICBCcomponent","text":"Initial and boundary condition components that can be combined to  create an DomainInfo object.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.constBC","page":"API Reference","title":"EarthSciMLBase.constBC","text":"Construct constant boundary conditions equal to the value  specified by val.\n\nval: The value of the constant boundary conditions.\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.constIC","page":"API Reference","title":"EarthSciMLBase.constIC","text":"Construct constant initial conditions equal to the value  specified by val.\n\nval: The value of the constant initial conditions.\nindepdomain: The independent domain, e.g. t ∈ Interval(t_min, t_max).\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.periodicBC","page":"API Reference","title":"EarthSciMLBase.periodicBC","text":"Construct periodic boundary conditions for the given partialdomains. Periodic boundary conditions are defined as when the value at one side of the domain is set equal to the value at the other side, so  that the domain \"wraps around\" from one side to the other.\n\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.zerogradBC","page":"API Reference","title":"EarthSciMLBase.zerogradBC","text":"Construct zero-gradient boundary conditions for the given partialdomains.\n\npartialdomains: The partial domains, e.g. [x ∈ Interval(x_min, x_max), y ∈ Interval(y_min, y_max)].\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.ConstantWind-Tuple{Any, Vararg{Any}}","page":"API Reference","title":"EarthSciMLBase.ConstantWind","text":"ConstantWind(t, vals)\n\n\nConstruct a constant wind velocity model component with the given wind speed(s), which should include units. For example, ConstantWind(t, 1u\"m/s\", 2u\"m/s\").\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.MeanWind-Tuple{Any, DomainInfo}","page":"API Reference","title":"EarthSciMLBase.MeanWind","text":"MeanWind(t, domain)\n\n\nA model component that represents the mean wind velocity, where pvars is the partial dependent variables for the domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.add_dims-Tuple{Any, AbstractVector, AbstractVector}","page":"API Reference","title":"EarthSciMLBase.add_dims","text":"add_dims(expression, vars, dims)\nadd_dims(equation, vars, dims)\n\nAdd the given dimensions to each variable in vars in the given expression or equation.  Each variable in vars must be unidimensional, i.e. defined like @variables u(t) rather than @variables u(..).\n\nExample:\n\nusing EarthSciMLBase, ModelingToolkit\n\n@parameters x y k t\n@variables u(t) q(t)\nexp = 2u + 3k*q + 1\nEarthSciMLBase.add_dims(exp, [u, q], [x, y, t])\n\n# output\n1 + 2u(x, y, t) + 3k*q(x, y, t)\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.add_metadata-Tuple{Any, Any}","page":"API Reference","title":"EarthSciMLBase.add_metadata","text":"Add the units and description in the variable from to the variable to.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.add_scope-Tuple{Any, Any, Any}","page":"API Reference","title":"EarthSciMLBase.add_scope","text":"add_scope(sys, v, iv)\n\n\nAdd a system scope to a variable name, for example so that  x in system sys1 becomes sys1₊x. iv is the independent variable.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.couple-Tuple","page":"API Reference","title":"EarthSciMLBase.couple","text":"couple(systems...) -> CoupledSystem\n\n\nCouple multiple ModelingToolkit systems together.\n\nThe systems that are arguments to this system can be of type ModelingToolkit.AbstractSystem,  CoupledSystem, DomainInfo,  or any type T that has a method couple(::CoupledSystem, ::T)::CoupledSystem or a method  couple(::T, ::CoupledSystem)::CoupledSystem defined for it.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.dims-Tuple{EarthSciMLBase.ICcomponent}","page":"API Reference","title":"EarthSciMLBase.dims","text":"dims(\n    icbc::EarthSciMLBase.ICcomponent\n) -> Vector{Symbolics.Num}\n\n\nReturns the dimensions of the independent and partial domains associated with these  initial or boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.domains-Tuple{EarthSciMLBase.ICcomponent}","page":"API Reference","title":"EarthSciMLBase.domains","text":"domains(icbc::EarthSciMLBase.ICcomponent) -> Vector\n\n\nReturns the domains associated with these initial or boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.get_dv-Tuple{Any, Any}","page":"API Reference","title":"EarthSciMLBase.get_dv","text":"Return the dependent variable, which is the first argument of the term,  unless the term is a time derivative, in which case the dependent variable  is the argument of the time derivative.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.get_mtk-Tuple{CoupledSystem}","page":"API Reference","title":"EarthSciMLBase.get_mtk","text":"get_mtk(sys; name)\n\n\nGet the ModelingToolkit representation of a CoupledSystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.graph-Tuple{CoupledSystem}","page":"API Reference","title":"EarthSciMLBase.graph","text":"Create a graph from a CoupledSystem using the MetaGraphsNext package.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.icbc-Tuple{DomainInfo, AbstractVector}","page":"API Reference","title":"EarthSciMLBase.icbc","text":"icbc(di, states)\n\n\nReturn a vector of equations that define the initial and boundary conditions for the  given state variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.ivar-Tuple{DomainInfo}","page":"API Reference","title":"EarthSciMLBase.ivar","text":"ivar(di::DomainInfo) -> Any\n\n\nReturn the independent variable associated with these  initial and boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.operator_compose","page":"API Reference","title":"EarthSciMLBase.operator_compose","text":"operator_compose(a, b)\noperator_compose(a, b, translate)\n\n\nCompose to systems of equations together by adding the right-hand side terms together of equations that have matching left-hand sides. The left hand sides of two equations will be considered matching if:\n\nThey are both time derivatives of the same variable.\nThe first one is a time derivative of a variable and the second one is the variable itself.\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, e.g. Dict(sys1.sys.x => sys2.sys.y).\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, with a conversion factor, e.g. Dict(sys1.sys.x => sys2.sys.y => 6).\n\n\n\n\n\n","category":"function"},{"location":"api/#EarthSciMLBase.param_to_var-Tuple{ModelingToolkit.AbstractSystem, Vararg{Symbol}}","page":"API Reference","title":"EarthSciMLBase.param_to_var","text":"Replace the parameter p in the system sys with a new variable that has  the same name, units, and description as p.\n\nparam_to_var(sys, ps)\n\n\nThis can be useful to replace a parameter that does not change in time in a model component  with one specified by another system that does change in time (or space). For example, the  code below specifies a first-order loss equation, and then changes the temperature (which  determines the loss rate) with a temperature value that varies in time. ```\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.partialderivative_transforms-Tuple{DomainInfo}","page":"API Reference","title":"EarthSciMLBase.partialderivative_transforms","text":"partialderivative_transforms(di::DomainInfo) -> Vector{Any}\n\n\nReturn transform factor to multiply each partial derivative operator by, for example to convert from degrees to meters.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.partialderivatives-Tuple{DomainInfo}","page":"API Reference","title":"EarthSciMLBase.partialderivatives","text":"partialderivatives(di::DomainInfo) -> Any\n\n\nReturn the partial derivative operators for the given domain.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.partialderivatives_δxyδlonlat-Tuple{AbstractVector}","page":"API Reference","title":"EarthSciMLBase.partialderivatives_δxyδlonlat","text":"partialderivatives_δxyδlonlat(pvars; default_lat)\n\n\nReturn partial derivative operator transform factors corresponding  for the given partial-independent variables after converting variables named lon and lat from degrees to x and y meters,  assuming they represent longitude and latitude on a spherical Earth.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.pvars-Tuple{DomainInfo}","page":"API Reference","title":"EarthSciMLBase.pvars","text":"pvars(di::DomainInfo) -> Any\n\n\nReturn the partial independent variables associated with these  initial and boundary conditions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.register_coupling-Tuple{Function, ModelingToolkit.AbstractSystem, ModelingToolkit.AbstractSystem}","page":"API Reference","title":"EarthSciMLBase.register_coupling","text":"register_coupling(f, a, b)\n\n\nRegister a coupling function for two systems.\n\nIn the get_mtk method of CoupledSystem, the function f is called to make any edits needed to the two systems before they are composed together, and also to return a ConnectorSystem that represents the coupling of the two systems.\n\nThe function f should take as two ODESystems and return a ConnectorSystem, i.e.  f(a::ODESystem, b::ODESystem)::ConnectorSystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EarthSciMLBase.systemhash-Tuple{ModelingToolkit.AbstractSystem}","page":"API Reference","title":"EarthSciMLBase.systemhash","text":"Return a unique identifier for a system. \n\n\n\n\n\n","category":"method"},{"location":"icbc/#Initial-and-Boundary-conditions","page":"Initial and Boundary Conditions","title":"Initial and Boundary conditions","text":"","category":"section"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Oftentimes we will want to do a 1, 2, or 3-dimensional simulation, rather than the 0-dimensional simulation we get by default with a system of ordinary differential equations. In these cases, we will need to specify initial and boundary conditions for the system.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"To demonstrate how to do this, we will use the following simple system of ordinary differential equations:","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"using EarthSciMLBase\nusing ModelingToolkit\n\n@parameters x y t\n\nfunction ExampleSys(t)\n    @variables u(t) v(t)\n    Dt = Differential(t)\n    eqs = [\n        Dt(u) ~ √abs(v),\n        Dt(v) ~ √abs(u),\n    ]\n    ODESystem(eqs, t; name=:Docs₊Example)\nend\n\nExampleSys(t)","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Next, we specify our initial and boundary conditions using the DomainInfo type. We initialize DomainInfo with sets of initial and boundary conditions. In the example below, we set constant initial conditions using constIC and constant boundary conditions using constBC.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"using DomainSets\n\nx_min = y_min = t_min = 0.0\nx_max = y_max = t_max = 1.0\n\n# Create constant initial conditions = 16.0 and boundary conditions = 4.0.\nicbc = DomainInfo(\n    constIC(4.0, t ∈ Interval(t_min, t_max)),\n    constBC(16.0,\n        x ∈ Interval(x_min, x_max),\n        y ∈ Interval(y_min, y_max),\n    ),\n)\nnothing # hide","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"It is also possible to use periodic boundary conditions with periodicBC and zero-gradient boundary conditions with zerogradBC.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"Finally, we combine our initial and boundary conditions with our system of equations using the couple function.","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"model = couple(ExampleSys(t), icbc)\n\neq_sys = get_mtk(model)","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"We can also look at the expanded boundary conditions of the resulting equation system:","category":"page"},{"location":"icbc/","page":"Initial and Boundary Conditions","title":"Initial and Boundary Conditions","text":"eq_sys.bcs","category":"page"},{"location":"operator_compose/#Operator-Composition","page":"Operator Composition","title":"Operator Composition","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"There are a lot of cases where there are two different \"processes\" or \"operators\" that change the same variable.  For example, CO2 in the atmosphere can be emitted by human activity, and it can also be absorbed by the ocean. In models, typically the emission and removal are considered separate processes which are represented by separate model components. However, when we want to combine these two components into a single model, we need to be able to compose them together.","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"We can use the operator_compose function for this. It composes to systems of equations together by adding the right-hand side terms together of equations that have matching left-hand sides. The left hand sides of two equations will be considered matching if:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"They are both time derivatives of the same variable.\nThe first one is a time derivative of a variable and the second one is the variable itself.\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, e.g. Dict(sys1.sys.x => sys2.sys.y).\nThere is an entry in the optional translate dictionary that maps the dependent variable in the first system to the dependent variable in the second system, with a conversion factor, e.g. Dict(sys1.sys.x => sys2.sys.y => 6).","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"Perhaps we can make this somewhat clearer with some examples.","category":"page"},{"location":"operator_compose/#Examples","page":"Operator Composition","title":"Examples","text":"","category":"section"},{"location":"operator_compose/#Example-with-matching-variable-time-derivatives","page":"Operator Composition","title":"Example with matching variable time derivatives","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"The example below shows that when we operator_compose two systems together that are both equal to D(x) = p, the resulting system is equal to D(x) = 2p.","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"using EarthSciMLBase\nusing ModelingToolkit\n\n@parameters t\n\nfunction ExampleSys(t)\n    @variables x(t)\n    @parameters p\n    D = Differential(t)\n    ODESystem([D(x) ~ p], t; name=:Docs₊ExampleSys)\nend\n\nExampleSys(t)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"function ExampleSys2(t)\n    @variables x(t)\n    @parameters p\n    D = Differential(t)\n    ODESystem([D(x) ~ 2p], t; name=:Docs₊ExampleSys2)\nend\n\nExampleSys2(t)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"sys1 = ExampleSys(t)\nsys2 = ExampleSys2(t)\n\nregister_coupling(ExampleSys(t), ExampleSys2(t)) do sys1, sys2\n    operator_compose(sys1, sys2)\nend\n\ncombined = couple(sys1, sys2)\n\ncombined_mtk = get_mtk(combined)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"The simplified equation should be D(x) = p + sys2_xˍt:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"combined_simplified = structural_simplify(combined_mtk)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"where sys2_xˍt is also equal to p:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(combined_simplified)","category":"page"},{"location":"operator_compose/#Example-with-non-matching-variables","page":"Operator Composition","title":"Example with non-matching variables","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"This example demonstrates a case where one variable in the first system is equal to another variable in the second system:","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"function ExampleSys3(t)\n    @variables y(t)\n    @parameters p\n    D = Differential(t)\n    ODESystem([D(y) ~ p], t; name=:Docs₊ExampleSys3)\nend\n\nsys1 = ExampleSys(t)\nsys2 = ExampleSys3(t)\n\nregister_coupling(ExampleSys(t), ExampleSys3(t)) do sys1, sys2\n    operator_compose(sys1, sys2, Dict(sys1.x => sys2.y))\nend\n\ncombined = couple(sys1, sys2)\ncombined_simplified = structural_simplify(get_mtk(combined))","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(combined_simplified)","category":"page"},{"location":"operator_compose/#Example-with-a-non-ODE-system","page":"Operator Composition","title":"Example with a non-ODE system","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"In the second case above, we might have a variable in the second system that is equal to a rate, but it is not a time derivative. This could happen if we are extracting emissions from a file, and those emissions are already in units of kg/s, or something similar. The example below demonstrates this case.  (Note that this case can also be used with the conversion factors shown in the last example.)","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"function ExampleSysNonODE(t)\n    @variables y(t)\n    @parameters p\n    ODESystem([y ~ p], t; name=:Docs₊ExampleSysNonODE)\nend\n\nsys1 = ExampleSys(t)\nsys2 = ExampleSysNonODE(t)\n\nregister_coupling(ExampleSys(t), ExampleSysNonODE(t)) do sys1, sys2\n    operator_compose(sys1, sys2, Dict(sys1.x => sys2.y))\nend\n\ncombined = couple(sys1, sys2)\nsys_combined = structural_simplify(get_mtk(combined))","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(sys_combined)","category":"page"},{"location":"operator_compose/#Example-with-non-matching-variables-and-a-conversion-factor","page":"Operator Composition","title":"Example with non-matching variables and a conversion factor","text":"","category":"section"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"Finally, this last example shows the fourth case, where a conversion factor is included in the translation dictionary.","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"function ExampleSysNonODE2(t)\n    @variables y(t)\n    @parameters p\n    ODESystem([y ~ p], t; name=:Docs₊ExampleSysNonODE2)\nend\n\nsys1 = ExampleSys(t)\nsys2 = ExampleSysNonODE2(t)\n\nregister_coupling(ExampleSys(t), ExampleSysNonODE2(t)) do sys1, sys2\n    operator_compose(sys1, sys2, Dict(sys1.x => sys2.y => 6.0))\nend\n\ncombined = couple(sys1, sys2)\ncombined_simplified = structural_simplify(get_mtk(combined))","category":"page"},{"location":"operator_compose/","page":"Operator Composition","title":"Operator Composition","text":"observed(combined_simplified)","category":"page"},{"location":"param_to_var/#Converting-parameters-to-variables","page":"Parameter Replacement","title":"Converting parameters to variables","text":"","category":"section"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"This can be useful to replace a parameter that does not change in time in a model component  with one specified by another system that does change in time (or space). For example, the  code below specifies a first-order loss equation, and then changes the temperature (which  determines the loss rate) with a temperature value that varies in time.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"As an example, we will create a loss equation that depends on the temperature, starting with a constant temperature. We will then create a temperature equation that varies in time, and use the param_to_var function to replace the constant temperature in the loss equation with the time-varying temperature.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"So first, let's specify the original system with constant temperature.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"using ModelingToolkit, EarthSciMLBase, Unitful\n\n@variables t [unit=u\"s\", description=\"time\"]\n\nfunction Loss(t)\n    @variables A(t)=1 [unit=u\"kg\"]\n    @parameters k=1 [unit=u\"s^-1\"]\n    @parameters T=300 [unit=u\"K\"]\n    @constants T₀=300 [unit=u\"K\"]\n    eq = Differential(t)(A) ~ -k*exp(T/T₀) * A\n    ODESystem([eq]; name=:Docs₊Loss)\nend\n\nLoss(t)","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"Next, we specify the temperature that varies in time.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"function Temperature(t)\n    @variables T(t)=300 [unit=u\"K\"]\n    @constants Tc=1.0 [unit=u\"K/s\"]\n    @constants tc=1.0 [unit=u\"s\"]\n    eq = Differential(t)(T) ~ sin(t/tc)*Tc\n    ODESystem([eq]; name=:Docs₊Temperature)\nend\n\nTemperature(t)","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"Now, we specify how to compose the two systems using param_to_var.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"register_coupling(Loss(t), Temperature(t)) do loss, temp\n    loss = param_to_var(loss, :T)\n    ConnectorSystem([loss.T ~ temp.T], loss, temp)\nend","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"Finally, we create the system components and the composed system.","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"l = Loss(t)\nt = Temperature(t)\nvariable_loss = couple(l, t)\n\nget_mtk(variable_loss)","category":"page"},{"location":"param_to_var/","page":"Parameter Replacement","title":"Parameter Replacement","text":"If we wanted to, we could then run a simulation with the composed system.","category":"page"},{"location":"coord_transforms/#Coordinate-Transforms-for-Partial-Derivatives","page":"Coordinate Transforms","title":"Coordinate Transforms for Partial Derivatives","text":"","category":"section"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"Often, the coordinates of a grid may be defined in a different coordinate system than the one in which the partial derivatives are desired. For example, grids are often defined in latitude and longitude, but partial derivatives may be required in units of meters to correspond with wind speeds in meters per second.","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"To handle this, the DomainInfo type can be used to define coordinate system transformations. To use it, a coordinate transform function first needs to be defined, for example partialderivatives_δxyδlonlat which transforms partial derivatives from longitude and latitude to meters:","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"using EarthSciMLBase\nusing ModelingToolkit\nusing DomainSets\nusing Unitful\n\n@parameters lon [unit = u\"rad\"]\n@parameters lat [unit = u\"rad\"]\n@parameters t [unit = u\"s\"]\n@parameters lev\n\npartialderivatives_δxyδlonlat([lev, lon, lat])","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"As you can see in the output of the code above, the function should take as arguments a list of the coordinates describing the grid (in the case above we have a 3-dimensional grid with vertical level, latitude, and longitude), and return a Dictionary relating the index of each coordinate with a factor to multiply the partial derivative by to convert it to the desired units. The function only needs to return factors for the coordinates that are being transformed.","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"To include a coordinate transform in our domain, we include the function in the DomainInfo constructor:","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"deg2rad(x) = x * π / 180.0\ndomain = DomainInfo(\n    partialderivatives_δxyδlonlat,\n    constIC(0.0, t ∈ Interval(0.0f0, 3600.0f0)),\n    periodicBC(lat ∈ Interval(deg2rad(-90.0f0), deg2rad(90.0f0))),\n    periodicBC(lon ∈ Interval(deg2rad(-180.0f0), deg2rad(180.0f0))),\n    zerogradBC(lev ∈ Interval(1.0f0, 10.0f0)),\n);","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"Multiple functions can be included in the DomainInfo constructor, just by including them as a vector, e.g.:","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"domain = DomainInfo(\n    [transform1, transform2, ...],\n    constIC(0.0, t ∈ Interval(0.0f0, 3600.0f0)),\n    ...\n)","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"After we include the coordinate transforms in our domain, in general everything should be handled automatically.  The coordinate transforms may also be automatically added when different model components are coupled together, so you may not need to worry about them at all in many cases. However, if you would like to use the transformed partial derivatives, for example to create a new PDE equation system, you can get them using the EarthSciMLBase.partialderivatives function:","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"δs = partialderivatives(domain)","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"This returns a list of functions, one corresponding to each coordinate in our domain. Then we can calculate the symbolic partial derivative of a variable by just calling each function:","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"@variables u\n\n[δs[i](u) for i ∈ eachindex(δs)]","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"You can see an example of how this is implemented in the source code for the Advection model component.","category":"page"},{"location":"coord_transforms/","page":"Coordinate Transforms","title":"Coordinate Transforms","text":"Additional transformation functions may be defined in other packages. We recommend that the names of these functions start with partialderivatives_ to make it clear that they are intended to be used in this context.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"CurrentModule = EarthSciMLBase","category":"page"},{"location":"example_all_together/#Example-using-different-components-of-EarthSciMLBase-together","page":"All Together","title":"Example using different components of EarthSciMLBase together","text":"","category":"section"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"This example shows how to define and couple different components of EarthSciMLBase together to create a more complex model. First, we create several model components.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Our first example system is a simple reaction system:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"using EarthSciMLBase\nusing ModelingToolkit, Catalyst, DomainSets, MethodOfLines, DifferentialEquations\nusing Plots\n\n# Create our independent variable `t` and our partially-independent variables `x` and `y`.\n@parameters t x y\n\nfunction ExampleSys1(t)\n    @species c₁(t)=5.0 c₂(t)=5.0\n    ReactionSystem(\n        [Reaction(2.0, [c₁], [c₂])],\n        t; name=:Docs₊Sys1, combinatoric_ratelaws=false)\nend\n\nExampleSys1(t)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Our second example system is a simple ODE system, with the same two variables.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"function ExampleSys2(t)\n    @variables c₁(t)=5.0 c₂(t)=5.0\n    @parameters p₁=1.0 p₂=0.5\n    D = Differential(t)\n    ODESystem(\n        [D(c₁) ~ -p₁, D(c₂) ~ p₂],\n        t; name=:Docs₊Sys2)\nend\n\nExampleSys2(t)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Now, we specify what should happen when we couple the two systems together. In this case, we want the the derivative of the composed system to  be equal to the sum of the derivatives of the two systems. We can do that using the operator_compose function  from this package.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"register_coupling(ExampleSys1(t), ExampleSys2(t)) do sys1, sys2\n    sys1 = convert(ODESystem, sys1)\n    operator_compose(sys1, sys2)\nend\nnothing # hide","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Once we specify all of the above, it is simple to create our two individual systems and then couple them together. ","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"sys1 = ExampleSys1(t)\nsys2 = ExampleSys2(t)\nsys = couple(sys1, sys2)\n\nget_mtk(sys)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"At this point we have an ODE system that is composed of two other ODE systems. We can inspect its observed variables using the observed function.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"simplified_sys = structural_simplify(get_mtk(sys))","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"observed(simplified_sys)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"We can also run simulations using this system:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"odeprob = ODEProblem(simplified_sys, [], (0.0,10.0), [])\nodesol = solve(odeprob)\nplot(odesol)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Once we've confirmed that our model works in a 0D \"box model\" setting, we can expand it to 1, 2, or 3 dimensions using by adding in initial  and boundary conditions. We will also add in advection using constant-velocity wind fields add the same time.","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"x_min = y_min = t_min = 0.0\nx_max = y_max = t_max = 1.0\ndomain = DomainInfo(\n    constIC(4.0, t ∈ Interval(t_min, t_max)),\n    periodicBC(x ∈ Interval(x_min, x_max)),\n    zerogradBC(y ∈ Interval(y_min, y_max)),\n)\n\nsys_pde = couple(sys, domain, ConstantWind(t, 1.0, 1.0), Advection())\n\nsys_pde_mtk = get_mtk(sys_pde)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Now we can inspect this new system that we've created:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"sys_pde_mtk.dvs","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"sys_pde_mtk.bcs","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Finally, we can run a simulation using this system:","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"discretization = MOLFiniteDifference([x=>10, y=>10], t, approx_order=2)\n@time pdeprob = discretize(sys_pde_mtk, discretization)\n@time pdesol = solve(pdeprob, Tsit5(), saveat=0.1)\n\n# Plot the solution.\ndiscrete_x, discrete_y, discrete_t = pdesol[x], pdesol[y], pdesol[t]\n@variables Docs₊Sys1₊c₁(..) Docs₊Sys1₊c₂(..)\nsolc1, solc2 = pdesol[Docs₊Sys1₊c₁(t, x, y)], pdesol[Docs₊Sys1₊c₂(t, x, y)]\nanim = @animate for k in 1:length(discrete_t)\n    p1 = heatmap(solc1[k, 1:end-1, 1:end-1], title=\"c₁ t=\\$(discrete_t[k])\", clim=(0,4.0), lab=:none)\n    p2 = heatmap(solc2[k, 1:end-1, 1:end-1], title=\"c₂ t=\\$(discrete_t[k])\", clim=(0,7.0), lab=:none)\n    plot(p1, p2, layout=(1,2), size=(800,400))\nend\ngif(anim, fps = 8)","category":"page"},{"location":"example_all_together/","page":"All Together","title":"All Together","text":"Because our system is a system of ordinary differential equations rather than partial differential equations, all of the grid cells in the animation above have the same value. Refer to the advection example for an example of a system of partial differential equations.","category":"page"},{"location":"composition/#Model-Composition","page":"Composition","title":"Model Composition","text":"","category":"section"},{"location":"composition/","page":"Composition","title":"Composition","text":"A main goal of the EarthSciMLBase package is to allow model components to be created independently and composed together. We achieve this by creating a registry of \"coupling functions\" that define how to connect different model components together.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"To demonstrate how this works, below we define three model components, Photolysis, Chemistry, and Emissions, which represent different processes in the atmosphere.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"using ModelingToolkit, Catalyst, EarthSciMLBase\n@parameters t\n\nfunction Photolysis(t)\n    @variables j_NO2(t)\n    eqs = [\n        j_NO2 ~ max(sin(t/86400),0)\n    ]\n    ODESystem(eqs, t, [j_NO2], []; name=:Docs₊Photolysis)\nend\n\nPhotolysis(t)","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"function Chemistry(t)\n    @parameters jNO2\n    @species NO2(t)\n    rxs = [\n        Reaction(jNO2, [NO2], [], [1], [1])\n    ]\n    ReactionSystem(rxs, t, [NO2], [jNO2]; \n        combinatoric_ratelaws=false, name=:Docs₊Chemistry)\nend\n\nChemistry(t)","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"function Emissions(t)\n    @parameters emis = 1\n    @variables NO2(t)\n    eqs = [NO2 ~ emis]\n    ODESystem(eqs, t, [NO2], [emis]; name=:Docs₊Emissions)\nend\n\nEmissions(t)","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Now, we need to define ways to couple the model components together. We can do this by defining a coupling function for each pair of model components that we want to couple, and registering the coupling functions with the register_coupling function. Each coupling function should have the signature (f::Function, sys1::AbstractSystem, sys2::AbstractSystem), where sys1 and sys2 are instances of the model components to be coupled, and f is the coupling function that takes the two model components as arguments, makes any edits to the components as needed, and returns a ConnectorSystem which defines the relationship between the two components.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"The code below defines a method for coupling the Chemistry and Photolysis components.  First, it uses the param_to_var function to convert the photolysis rate parameter jNO2 from the Chemistry component to a variable, then it creates a new Chemistry component with the updated photolysis rate, and finally, it creates a ConnectorSystem object that sets the j_NO2 variable from the Photolysis component equal to the jNO2 variable from the Chemistry component. The next effect is that the photolysis rate in the Chemistry component is now controlled by the Photolysis component.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"register_coupling(Chemistry(t), Photolysis(t)) do c, p \n    c = param_to_var(convert(ODESystem, c), :jNO2)\n    ConnectorSystem([c.jNO2 ~ p.j_NO2], c, p)\nend\nnothing # hide","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Next, we define a method for coupling the Chemistry and Emissions components. To do this we use the operator_compose function to add the NO2 species from the Emissions component to the time derivative of NO2 in the Chemistry component.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"register_coupling(Chemistry(t), Emissions(t)) do c, emis\n    operator_compose(convert(ODESystem, c), emis, Dict(\n        c.NO2 => emis.NO2,\n    ))\nend\nnothing # hide","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Finally, we can compose the model components together to create our complete model. To do so, we just initialize each model component and add the components together using the couple function. We can use the get_mtk function to convert the composed model to a ModelingToolkit model so we can see what the combined equations look like.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"model = couple(Photolysis(t), Chemistry(t), Emissions(t))\nget_mtk(model)","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"Finally, we can use the graph function to visualize the model components and their connections.","category":"page"},{"location":"composition/","page":"Composition","title":"Composition","text":"using MetaGraphsNext\nusing CairoMakie, GraphMakie\n\ng = graph(model)\n\nf, ax, p = graphplot(g; ilabels=labels(g))\nhidedecorations!(ax); hidespines!(ax); ax.aspect = DataAspect()\n\nf","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = EarthSciMLBase","category":"page"},{"location":"#EarthSciMLBase:-Utilities-for-Symbolic-Earth-Science-Modeling-and-Machine-Learning","page":"Home","title":"EarthSciMLBase: Utilities for Symbolic Earth Science Modeling and Machine Learning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EarthSciMLBase.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains utilities for constructing Earth Science models in Julia using ModelingToolkit.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"EarthSciMLBase\")","category":"page"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains types and functions designed to simplify the process of constructing and composing symbolically-defined Earth Science model components together.","category":"page"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Abstract types (based on AbstractEarthSciMLSystem) for wrapping ModelingToolkit.jl equation systems\nOperations to compose AbstractEarthSciMLSystems together using the + operator.\nOperations to add intitial and boundary conditions to systems and to turn ODE systems into PDE systems.\nOperations to add Advection terms to systems.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing.","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this EarthSciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"},{"location":"advection/#Advection","page":"Advection","title":"Advection","text":"","category":"section"},{"location":"advection/","page":"Advection","title":"Advection","text":"The Advection function adds advection to a system of equations. This is useful for modeling the transport of a substance by a fluid. Advection is implemented with the Advection type.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"!warning     Fully symbolic partial differential equations like those shown here don't currently work on domains that have a large number of grid cells. See here for additional information.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"To demonstrate how this can work, we will start with a simple system of equations:","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"using EarthSciMLBase, ModelingToolkit, Unitful\n\n@parameters t\n\nfunction ExampleSys(t)\n    @variables y(t)\n    @parameters p=2.0\n    D = Differential(t)\n    ODESystem([D(y) ~ p], t; name=:Docs₊ExampleSys)\nend\n\nExampleSys(t)","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"We also need to create our initial and boundary conditions.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"using DomainSets\n@parameters x\ndomain = DomainInfo(constIC(0.0, t ∈ Interval(0, 1.0)), constBC(1.0, x ∈ Interval(0, 1.0)))\nnothing # hide","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"Now we convert add advection to each of the state variables. We're also adding a constant wind (ConstantWind) in the x-direction, with a speed of 1.0.","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"sys_advection = couple(ExampleSys(t), domain, ConstantWind(t, 1.0), Advection())\nsys_mtk = get_mtk(sys_advection)","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"Finally, we can discretize the system and solve it:","category":"page"},{"location":"advection/","page":"Advection","title":"Advection","text":"using MethodOfLines, DifferentialEquations, Plots\ndiscretization = MOLFiniteDifference([x=>10], t, approx_order=2)\n@time prob = discretize(sys_mtk, discretization)\n@time sol = solve(prob, Tsit5(), saveat=0.1)\n\n\n# Plot the solution.\ndiscrete_x = sol[x]\ndiscrete_t = sol[t]\nsoly = sol[sys_mtk.dvs[3]]\nanim = @animate for k in 1:length(discrete_t)\n    plot(discrete_x, soly[k, 1:end], title=\"t=\\$(discrete_t[k])\", ylim=(0,2.5), lab=:none)\nend\ngif(anim, fps = 8)","category":"page"}]
}
